# Philosophy
Write clean, efficient, and readable code. Prioritize clarity and maintainability over cleverness. Optimize only when there is a proven need — not for theoretical micro-efficiency.
# Principles
Clarity > Cleverness
Code should be immediately understandable to someone new to the project. Prefer descriptive names, simple logic, and consistent style.
Simplicity > Overengineering
Do not add abstraction layers, custom frameworks, or patterns unless they solve a recurring problem. Favor straightforward solutions.
Practical Efficiency
Write code that runs efficiently enough for its purpose. Profile before optimizing. Small constant-time improvements rarely justify added complexity.
Consistency
Follow established conventions and project style guides. Consistent code is easier to debug, review, and extend.
Small, Focused Functions
Each function should do one thing well. Compose rather than nest deeply.
Comments Explain Why, Not What
Write self-documenting code; reserve comments for reasoning, trade-offs, or non-obvious decisions.
Fail Gracefully
Handle errors predictably. Avoid silent failures or complex exception hierarchies.
Test Simply
Write tests that verify core logic. Don’t test implementation details.